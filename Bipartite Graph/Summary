
双连通分量: 分为点-双连通分量和边-双连通分量。
           点-双连通分量: 在一个无向图中两点间至少有两条路径,且路径中的点不同,不同的点-双连通分量最多有一个公共点,该点为割顶(割点,cut vertex,即删去此点时,连通块的数量会增加)。
           边-双连通分量: 在一个无向图中两点间至少有两条路径,且路径中的边不同,边-双连通分量中一定没有桥(割边,bridge,即删去该边,连通块数量增加)。

二分图又称为二部图,设G=(V, E)是一个无向图。如果顶点集V可分割为两个互不相交的子集X和Y，并且图中每条边连接的两个顶点一个在X中，另一个在Y中，则称图G为二分图。
性质: 当且仅当无向图G的每一个回路的次数都是偶数时,G才是一个二分图。若没有回路,即次数为0,G也是一个二分图。
二分图判定: 交叉染色法。
           从任意一个节点出发,与其相邻的节点有三种状态: 1. 未染色,则将该节点染成另一种颜色
                                                    2. 已染色且与当前节点颜色不同,跳过该节点
                                                    3. 已染色但与当前节点颜色相同,则该图不是二分图  
                                                    
二分图匹配: 给定一个二分图G,在G的一个子图M中,M的边集{E}中的任意两条边都不依附于同一个顶点,则称M是一个匹配。
           选择边数最大的子图称为图的最大匹配(maximal matching)。如果一个匹配中,图中的每个顶点都和图中某条边相关联,则称为完全匹配,完全匹配一定是最大匹配。
交替路: 从一个未匹配点出发,依次经过非匹配边、匹配边、非匹配边...,形成的路径是交替路。
增广路(augmenting path): 从一个未匹配点出发,走交替路,如果途径另一个未匹配点(不包括出发点),则这条交替路称为增广路。
增广路定理: 增广路中,非匹配边比匹配边多一条。增广路用于改进匹配,即只要把增广路中的匹配边和非匹配边身份交换,交换后匹配的性质保留且匹配的边数增加了一条。
           通过不断地寻找增广路来增加匹配边数,当找不到合适的增广路时,达到最大匹配。
匈牙利算法(Hungarian algorithm): 基于增广路定理,对于每个可以与节点u匹配的节点v,假如它未被匹配,可以直接用节点v与节点u匹配;
                                如果节点v已与节点w匹配,则dfs(w)求证节点w是否可以与其他节点匹配,若可以则节点v可以与节点u匹配,否则检查节点u的下一个邻接点。
                                时间复杂度: O(V^3(邻接矩阵)),O(VE(邻接表)),空间复杂度: O(V^2(邻接矩阵)),O(V+E(邻接表))
          bool dfs(int u){ //寻找从节点u出发的增广路径
              for each v∈u的邻接点{
                  if(v未访问){
                      标记v已访问;
                      if(v未匹配||dfs(y[v])){
                          x[u]=v;
                          y[v]=u;
                          return true; //有从节点u出发的增广路径
                      }
                  }
              }
          }
          
Konig定理: 二分图中的最大匹配数等于这个图中的最小点覆盖数。
最小点覆盖数: 选择一个点表示覆盖了以该点为端点的所有边,选择最少的点来覆盖所有的边

对于带权完全二分图G,假设所有边权都非负,可用KM算法求权最大的完美匹配。
可行顶标(feasible vertex labeling): 是节点的实函数,满足对任意边(u,v)都有l(u)+l(v)>=w(u,v)。
相等子图(equality subgraph): 是图G的生成子图,即包含所有节点,但只包含满足l(u)+l(v)=w(u,v)的边(u,v)。
                            如果相等子图有完美匹配,则该匹配是原图G的最大权完美匹配。
KM算法(Kuhn-Munkres算法): 首先任意设置可行顶标,一般可初始化lx(u)为与节点u相连的边的最大权值,ly(v)=0
                         搜索寻找增广路,若从某节点不能找到增广路,则此时令X为搜索中左点集中已访问的点,Y为右点集中已访问的点,将X中的点的顶标降低且将Y中的点的顶标增加,
                         增减量为d=min(l(x)+l(y)-w(x,y)),其中x属于X,y不属于Y,该增减量既可以满足有新边加入,也可以满足顶标可行。 
                         时间复杂度: O(n^4),O(n^3 (with slack))
                         定义slack(y)=min{(x,y)| lx(x)+ly(y)-W(x,y),x∈X,y∉Y},这样能在寻找增广路径的时候就顺便将slack求出。

1. LeetCode  785. Is Graph Bipartite?: 交叉染色DFS
             886. Possible Bipartite: 构建邻接表后交叉染色DFS
2. Codeforces  688C. NP-Hard Problem: 构建邻接表后交叉染色DFS,使用color^1=color'(0->1,1->0)来存储两部分为res[color]
               776D. The Door Problem: 开关只有两个可能的点集,以此划分二分图,构建合适的边并以当前门的状态决定两个开关是否属于同一点集
3. HDU  2444. The Accomodation of Students: 先判断是否为二分图,然后由匈牙利算法求得最大匹配
        2063. 过山车: 最大匹配模板题,注意u->v中两个节点的序号,u=u,v=v+m(m为点u的总数)
        1150. Machine Schedule: 两个machine的所有mode为节点划分二分图,求最少的mode数使得覆盖所有边,即求最小点覆盖=求最大匹配
        2255. 奔小康赚大钱: KM算法求最大权完美匹配模板题
4. POJ  3041. Asteroids: 将行列抽象为点,矩阵里的点抽象为连接行列的边,则该点的行列不能同时出现在同一集合里,构成二分图,求最小点覆盖        
        1274. The Perfect Stall: 最大匹配模板题
        2239. Selecting Courses: 以课程号和课程时间(需要hash)为两个点集划分二分图,寻找最大匹配,注意只需要一条从课程号到课程时间的边
        2195. Going Home
           
