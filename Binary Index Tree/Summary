
用于快速修改和查询一个给定数字的序列中,某个区间内值的和,使用范围比线段树小但代码量小并且效率更高。

C数组表示树状数组,A数组表示原数组,则

                   _______________________C[8]
                   |                       |
       ___________C[4]         ____________#
       |           |           |           |
  ____C[2]    _____#     _____C[6]    _____#
  |    |      |    |     |     |      |    |
C[1]   #    C[3]   #    C[5]   #    C[7]   #

A[1]  A[2]  A[3]  A[4]  A[5]  A[6]  A[7]  A[8]

C[1]=A[1];
C[2]=A[1]+A[2];
C[3]=A[3];
C[4]=A[1]+A[2]+A[3]+A[4];
C[5]=A[5];
C[6]=A[5]+A[6];
C[7]=A[7];
C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];

1=(001)      C[1]=A[1];
2=(010)      C[2]=A[1]+A[2];
3=(011)      C[3]=A[3];
4=(100)      C[4]=A[1]+A[2]+A[3]+A[4];
5=(101)      C[5]=A[5];
6=(110)      C[6]=A[5]+A[6];
7=(111)      C[7]=A[7];
8=(1000)     C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];

C[i]=A[i-2^k+1]+A[i-2^k+2]+......A[i],k为i的二进制中从最低位到高位连续零的长度。
lowbit(x)取出x的最低位1,即lowbit(x)=2^k。
int lowbit(x){
  return x&(-x);
}


离散化: 若某些数字范围很大(如0-1e9),但是个数不算多(如1-1e5),并且这些数本身的数字大小不重要,重要的是这些数字之间的相对大小
        (比如说某个数字是这些数字中的第几小,而与这个数字本身大小没有关系,要的是相对位置)
        1. 定义一个离散化数组记录下所有值
        2. 根据题意选择如何排序
        3. 根据题意选择是否去重
        4. 重排后得到离散化的数字
        5. 使用二分查找得到某个值在离散化数组里的位置
